# My solution for At_Home

## 概要
* 独自の暗号方式を用いてるところが脆弱性になっている。
* (`n` を法とする世界で) `flag * e = c` なので普通に `e` で割る
* ソルバー：[solve.py](solve.py)

## 解答
```python
from Crypto.Util.number import *
e = 359050389152821553416139581503505347057925208560451864426634100333116560422313639260283981496824920089789497818520105189684311823250795520058111763310428202654439351922361722731557743640799254622423104811120692862884666323623693713
n = 26866112476805004406608209986673337296216833710860089901238432952384811714684404001885354052039112340209557226256650661186843726925958125334974412111471244462419577294051744141817411512295364953687829707132828973068538495834511391553765427956458757286710053986810998890293154443240352924460801124219510584689
c = 67743374462448582107440168513687520434594529331821740737396116407928111043815084665002104196754020530469360539253323738935708414363005373458782041955450278954348306401542374309788938720659206881893349940765268153223129964864641817170395527170138553388816095842842667443210645457879043383345869

print(long_to_bytes(c*pow(e,-1,n) % n).decode())
```
なお、より厳密には `n` と `e` が互いに素か確認する必要がある。

```console
$ python3 solve.py
uiuctf{W3_hav3_R5A_@_h0m3}
```
