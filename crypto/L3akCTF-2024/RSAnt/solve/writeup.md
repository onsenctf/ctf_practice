# My solution for RSAnt

RSA で暗号化された2種の暗号文 `c1`, `c2` が与えられている。
ところが、公開鍵 n が与えられていない。
そこでまずは `n` を求める
(注: `calc_n.sage` の計算結果は最大公約数にすぎないので、factordb などで素因数分解を試みて 2 などの小さい素因数は取り除いておく必要がある。)：

[`calc_n.sage`](./calc_n.sage)

```sage
from Crypto.Util.number import *

m1 = bytes_to_long(b"factoring modulus?")
m2 = bytes_to_long(b"without the modulus?")
c1 = 123377882241082251325350065419048806024607608617091688983830323277604694641240653374439302807138122463323990418348747537591347656262195555533468416119550902963546537686539626424151682647446653286178409257716563958279306978514921053134482777035689209563599648603507287706662378931300585730154813000147325737518201568052630101704051194396183990174893718130243703251255733422231215114594356086085529845721945162634747194330158630722370297888040809287372214916411109961066039419282486341414973486625115394106601990911459069075609672097833893961312251252396858703096951885954537748265354572684903035976149443662164781331591137509
c2 = 216996462348882812127549126696128848915007479735759067925583940914005783704777739383583486500248026532990006813147882357469539758674416271697210195684094572116588619081813131930186778045755089586040232978039441432232050042271853194470413044599117641325812011411950889172242559099135026172425733801215110286748370156962444409678069139574351948837982999861835569715249682828276876910129256029485173183675521926552841364713489224945222100475996799601024631599522598983661501357640196487134275394097207489818217501235732511301942649024362999538093008833593968191799917057618382726046836320499881842515455356124359654138411130319
e = 65537

print(gcd(m1**e - c1, m2**e - c2))
```


次にp, q を求める。
素数 p, q のビット数や e の値を見た限りでは、与えられた方式に脆弱性は無いように思えるが、 p, q の生成方法に問題がある：

`chal.sage: 8-9`

```sage
    tmp = randint(2**1023, 2**1024)
    p = next_prime(1337*tmp + randint(2, 2**512))
    q = next_prime(7331*tmp + randint(2, 2**512))
```

p, q の生成に、同じ `tmp` という1024 ビットの乱数が用いられている。
`randint(2, 2**512)` はこの `tmp` に比べるととてつもなく小さい値なので、 `p*7331` と `q*1337` がほぼ同じ値ということになる。

よって[フェルマー法](https://tex2e.github.io/blog/crypto/fermat-factorization-method) を用いて `p*7331` と `q*1337` が求めることで `p` `q` が得られるので、フラグも求まる。

[`solve.sage`](./solve.sage)

```sage
from Crypto.Util.number import *
import gmpy2

n = 573705313470237088128697724011345537729683894813773026784491075891375787623474876644061916906451471924722277144379030941570465205946833957200688304499122972757670018621482568140886956686009200092360197152239823056384412058625497863977546406937961142478700220534582896797390680947594209881481624425897931034297127910081669705880067174821720273642918776110649889916889528110735095592416817545242751005238512957101272680451113761426278203742295886722523975429342004312924930404678014280113729314434769051596435530057776346632601974236264442330943600999709043920136852080203441976582246277392355669576484507651557516413526616046 // 2
ciphertext = 179299686848994539141122382962230037744384497621603198124077003991636319769603564062817092353600906591207476251327282277695110268704615120068654776183507204512702766847930125900500659983050185274344899025779726523565280032908194763356944549824963215339419038543390439655210741510143003582737996617770895692162306286064421718892797213765237300926925675153074894532935937291295802157305724856321584517131226940140190491157709894421683196766707672593154406263054436900566231464719102312973247466510418770039194000878897515838985623461176782628261365771619698859295767451162504151010728056594695117040661023327968023451519804564

def fermat_factors(n):
    assert n % 2 != 0
    x = gmpy2.isqrt(n)
    y2 = x**2 - n
    while not gmpy2.is_square(y2):
        x += 1
        y2 = x**2 - n
    factor1 = x + gmpy2.isqrt(y2)  # a = x + y
    factor2 = x - gmpy2.isqrt(y2)  # b = x - y
    return int(factor1), int(factor2)

p_, q_ = fermat_factors(n*1337*7331)

p, q = (p_ // 1337, q_ // 7331) if isPrime(p_ // 1337) else (p_ // 7331, q_ //1337)

print(long_to_bytes(int(pow(ciphertext, pow(65537, -1, (p-1)*(q-1)), n))))

# => b'L3AK{All_H4Il_tH3_Gr3At_C0Pp3rsm1TH!!}'
```
