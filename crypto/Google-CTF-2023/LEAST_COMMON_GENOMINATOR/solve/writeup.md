# My solution for LEAST_COMMON_GENOMINATOR
## 概要
* 疑似乱数生成器としてLCGを用いていることと、その計算過程が漏れていることが脆弱性になっている。
* LCGの3つのパラメタを求め、与えられたファイル達を少し変更することでフラグが得られる。
* ソルバー：[solve.py](./solve.py), [generate.py](./generate.py), [secret.py](./secret.py)

## 解答
### 1. LCGのパラメタを求める
LCG (線形合同法) とは、以下の漸化式で定義される疑似乱数生成器のことである：

$` X_{i+1} = (m \cdot X_i + c)\ \text{mod}\ n `$

各パラメタ $m$, $c$, $n$ は、[generate.py](../given_files/generate.py) 内の以下のコードに対応している：

```python
class LCG:
    lcg_m = config.m
    lcg_c = config.c
    lcg_n = config.n
```

さて、この疑似乱数生成器は、生成されたいくつかの疑似乱数が漏洩した場合、 $m$, $c$, $n$ が求まってしまうことが知られている。漏洩した疑似乱数列 [dump.txt](../given_files/dump.txt) からパラメタ $m$, $c$, $n$ を求めるプログラムとして、[ここ](https://satto.hatenadiary.com/entry/solve-LCG) のコードをそのまま流用し [solve.py](./solve.py) を作成した。：

```console
$ python3 solve.py
n = 8311271273016946265169120092240227882013893131681882078655426814178920681968884651437107918874328518499850252591810409558783335118823692585959490215446923
m = 33498907266597000452412187812161084152798042715476613600511460967929272954073851020347029533815669725272752485010868463986784557605240931906995782519159773828367123850749356723229380711739507828128548590095063036261151441091797375422396872839507674559346637260353263392072879648565329366683514192327401491460
c = 3910539794193409979886870049869456815685040868312878537393070815966881265118275755165613835833103526090552456472867019296386475520134783987251699999776365
```

### 2. secret.py を再現する
generate.py は、 secret.py の config クラスから LCG のパラメタを読み込んでいる。ファイルが与えられた時点では config クラスの内容は削除されているので、これを手元で再現していく。 (余談だが、 config を yaml などからではなく python の クラスから読み込むテクニックを初めて知った。)

```python
class config:
    m = 33498907266597000452412187812161084152798042715476613600511460967929272954073851020347029533815669725272752485010868463986784557605240931906995782519159773828367123850749356723229380711739507828128548590095063036261151441091797375422396872839507674559346637260353263392072879648565329366683514192327401491460
    c = 3910539794193409979886870049869456815685040868312878537393070815966881265118275755165613835833103526090552456472867019296386475520134783987251699999776365
    n = 8311271273016946265169120092240227882013893131681882078655426814178920681968884651437107918874328518499850252591810409558783335118823692585959490215446923
    it = 8
    bits = 512
    e = 65537
```

`n`, `m`, `c` は solve.py で求めたものである。 `it`, `bits` は generate.py のアサーションを確認すればすぐに分かる。 `e` は openssl コマンドを用いて [public.pem](../given_files/public.pem) から読み込む：

```console
$ openssl rsa -pubin -inform PEM -text -modulus -noout < public.pem
# ... 省略 ...
Exponent: 65537 (0x10001)
# ... 省略 ...
```

### 3. generate.py を用いて復号する
前節までで、 LCG が生成する乱数列を完全に予測できるようになった。これにより、再び generate.py を実行することで(ランダムに生成されていたように見えていた) `it` 個の素数を全て割り出すことができる。 flag の暗号化には multi-prime RSA が使われているので、 `it` 個の素数と公開鍵 `n`, `e` が分かれば復号鍵 `d` を計算できる。

さて、暗号化されたフラグは [flag.txt](../given_files/flag.txt) にあるので、これを 16 進数でダンプする：

```console
$  xxd -p flag.txt | tr -d '\n' | fold -w2 | tac | tr -d '\n'
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000276f9162713d96423aca40a0a174cf129e6407c3ef4529b959ac53d99e0398182f6635725c0c60739a36081933b3248eb3c4ed61512329067dd5ae2226f9a607339b9cee7a31e1df39253099d6f01b57aa40e4598674bee9176253422c2a1e074c208e1bc21a8a5b67280a17ca70f094e4662a7ffff4371d655d8b4d91e8052bbab40a61565b469983373f1133f624289b95cf8b4f8a143dcfd05569e1441d3da5e9c644d049d1510f32bfbaf3a613e31fb5504a03cb88a47f35eeedefdf4df3ffebb3c46748bdcca512ea490ede8d732e355d2eef5639193fd97aca177f92069bd36b04fc0be2ccc61de239c461dced5a74c5a0ede0f2fd3cc3b2bf1076e501f50e371909894b6fc17509d87542b2ed04314fe70ab5aa1e121320dd1d9c786c046631e0526277d17baf9cf7ae7a268244709c1b547b748a41e25d86ed2f2089c7464091b4990ad0041afb30801353d70d1e51c42d74b072c8abd37f5f464e14db67b58915ca99a9510fdccd1d0f9f4de3b7e4306fff6033b0bdc10792980a4039232f42789ed3b380b4fc61c13914729d710f55af3e4516a8dd1b1d6066d8554a6d660ad703f33e9f38b9bf36f76b9ba39153c3cea92546e68eab4b34a1f9e2a0fcde9259320d81b36694c6d83174927b0db5425971ef0703ad9edcc7abcefd99c4e5af815adc1d0f16ef3eb09377ad5203fdb4b6b90796813109eea17134c
```

エンディアンの調整が必要だったのでやや煩雑なコマンドになってしまっている。 python の `open()` でうまくやれるのだと思うが、やり方が分からなかった。この出力の `276f91...` の部分をコピペし、暗号化されたフラグの値を変数に保存しておく。

あとは generate.py 内にもともとあった `d` を計算している行の下に、復号のコードを追記すればよい。
```python
# ... 省略 ...

    # Calculate private key 'd'
    d = pow(config.e, -1, phi)
    flag = 0x276f9162713d96423aca40a0a174cf129e6407c3ef4529b959ac53d99e0398182f6635725c0c60739a36081933b3248eb3c4ed61512329067dd5ae2226f9a607339b9cee7a31e1df39253099d6f01b57aa40e4598674bee9176253422c2a1e074c208e1bc21a8a5b67280a17ca70f094e4662a7ffff4371d655d8b4d91e8052bbab40a61565b469983373f1133f624289b95cf8b4f8a143dcfd05569e1441d3da5e9c644d049d1510f32bfbaf3a613e31fb5504a03cb88a47f35eeedefdf4df3ffebb3c46748bdcca512ea490ede8d732e355d2eef5639193fd97aca177f92069bd36b04fc0be2ccc61de239c461dced5a74c5a0ede0f2fd3cc3b2bf1076e501f50e371909894b6fc17509d87542b2ed04314fe70ab5aa1e121320dd1d9c786c046631e0526277d17baf9cf7ae7a268244709c1b547b748a41e25d86ed2f2089c7464091b4990ad0041afb30801353d70d1e51c42d74b072c8abd37f5f464e14db67b58915ca99a9510fdccd1d0f9f4de3b7e4306fff6033b0bdc10792980a4039232f42789ed3b380b4fc61c13914729d710f55af3e4516a8dd1b1d6066d8554a6d660ad703f33e9f38b9bf36f76b9ba39153c3cea92546e68eab4b34a1f9e2a0fcde9259320d81b36694c6d83174927b0db5425971ef0703ad9edcc7abcefd99c4e5af815adc1d0f16ef3eb09377ad5203fdb4b6b90796813109eea17134c
    print(long_to_bytes(pow(flag,d,n)))

# ... 省略 ...
```

### 4. 実行
```console
$ py3 generate.py
[+] Public Key:  10663197782188755187683519128391607889384236984841159980368295444757556251666173181966270935627381363634363152017932100870866073743196496182631686860974529519304898483583880797787662017633083156395595834399833548697123723014690019039843286516441722069672629491734333533874814655021750465470744221908153042891598629847474248035637833322061522018106952433195747728295433960640630861246440503259390376775374597599893181929337896828585045200809527092809746018806372033463639511758548910283175609247004446838778595246305426570138737826179346237355482797652195577697810275921391495040635386160960077290295503041318571091585994232128977189250560450541724526298324540333633756525782039764692046496665886338829810667477580556894564708344208454824227841439832096019161139930247745872364451624685509376111571650368725564985474387879414080347347860850162991841345901292668284154455326375190710973306072342463052980587717861754724857153296737480485351289440257347649463959856275061657492903860650820592573032713540474706170687783458640870091611869081448943812812946839710972240290444677129959352614435646729998203754847928052523568784250017348717982594389028978174915940120215557880850880860400503991453968452316505964854586987874049061874850121
[+] size:  4090 bits
b'CTF{C0nGr@tz_RiV35t_5h4MiR_nD_Ad13MaN_W0ulD_b_h@pPy}'

# ... 省略 ...
```

```console
CTF{C0nGr@tz_RiV35t_5h4MiR_nD_Ad13MaN_W0ulD_b_h@pPy}
```
