# My solution for math

まず、配布ファイルmath.tar.gzを展開すると、以下の三つのファイルが入っている。
- [`chal.py`](../given_files/chal.py)
- [`secret.py`](../given_files/secret.py)
- [`output.txt`](../given_files/output.txt)

名前からして、`chal.py`が暗号化実行ファイル、`secret.py`が秘密のパラメータ（flagなど）、`output.txt`が実行時の出力結果（これからflagを逆算する）と推測できる。

実際に内容を確認する。

[`chal.py`](../given_files/chal.py)
```python:chal.py
from Crypto.Util.number import bytes_to_long, isPrime
from secret import (
    x,
    p,
    q,
)  # x, p, q are secret values, please derive them from the provided other values.
import gmpy2


def is_square(n: int):
    return gmpy2.isqrt(n) ** 2 == n


assert isPrime(p)
assert isPrime(q)
assert p != q

a = p - x
b = q - x
assert is_square(x) and is_square(a) and is_square(b)

n = p * q
e = 65537
flag = b"ctf4b{dummy_f14g}"
mes = bytes_to_long(flag)
c = pow(mes, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"cipher = {c}")
print(f"ab = {a * b}")

# clews of factors
assert gmpy2.mpz(a) % 4701715889239073150754995341656203385876367121921416809690629011826585737797672332435916637751589158510308840818034029338373257253382781336806660731169 == 0
assert gmpy2.mpz(b) % 35760393478073168120554460439408418517938869000491575971977265241403459560088076621005967604705616322055977691364792995889012788657592539661 == 0
```

[`secret.py`](../given_files/secret.py)
```python:secret.py
import gmpy2

p = # REDUCTED
q = # REDUCTED
x = # REDUCTED
```

[`output.txt`](../given_files/output.txt)
```txt:output.txt
n = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649220231238608229533197681923695173787489927382994313313565230817693272800660584773413406312986658691062632592736135258179504656996785441096071602835406657489695156275069039550045300776031824520896862891410670249574658456594639092160270819842847709283108226626919671994630347532281842429619719214221191667701686004691774960081264751565207351509289
e = 65537
cipher = 21584943816198288600051522080026276522658576898162227146324366648480650054041094737059759505699399312596248050257694188819508698950101296033374314254837707681285359377639170449710749598138354002003296314889386075711196348215256173220002884223313832546315965310125945267664975574085558002704240448393617169465888856233502113237568170540619213181484011426535164453940899739376027204216298647125039764002258210835149662395757711004452903994153109016244375350290504216315365411682738445256671430020266141583924947184460559644863217919985928540548260221668729091080101310934989718796879197546243280468226856729271148474
ab = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649102926524363237634349331663931595027679709000404758309617551370661140402128171288521363854241635064819660089300995273835099967771608069501973728126045089426572572945113066368225450235783211375678087346640641196055581645502430852650520923184043404571923469007524529184935909107202788041365082158979439820855282328056521446473319065347766237878289
```

おおむね推測通り、`chal.py`が暗号化実行ファイル、`secret.py`が秘密のパラメータ $p$、 $q$、 $x$（値は~検閲済~ 秘匿済）、`output.txt`が実行時の出力結果（この出力結果からflagを逆算する）のようである。

`chal.py`がどのような処理を行っているのか、上から順に眺める。

- 関数`is_square(n: int)`
    - $n$ の平方根の2乗が $n$ と一致するかどうか、すなわち $n$ が平方数であるかどうかを、bool型（True, False）で返す。
- `assert isPrime(p)`, `assert isPrime(q)`
    - $p$, $q$ が素数であるかの判定を行っている。
    - 出力結果から、実行時に判定を通過しているので $p$, $q$ は素数である。
- `assert p != q`
    - $p \neq q$ であるかの判定を行っている。
    - 出力結果から、実行時に判定を通過しているので $p \neq q$ である。
- `a = p - x`, `b = q - x`
    - そのままの意味なので説明は省略。
- `assert is_square(x) and is_square(a) and is_square(b)`
    - $x$, $a$, $b$ が平方数であるかどうかの判定を関数is_squareで行っている。
- `n = p * q`, `e = 65537`
    - そのままの意味なので説明は省略。
- `flag = b"ctf4b{dummy_f14g}"`
    - flag文字列をバイト列リテラルとして入力している。
    - 配布ファイルではダミーのflagが入力されている模様。
- `mes = bytes_to_long(flag)`
    - flag文字列をbytes_to_long関数で数値に変換している。
- `c = pow(mes, e, n)`
    - $c = mes^{e} \mod n$ を求めている、すなわちflagをRSAで暗号化している。
- `print`文
    - $n$, $e$, $c$, $ab$ （ $ab = a \times b$ ）の出力を行っている。
- `assert`文
    - $a$, $b$ を続く値で割った時の余りが0であるかどうかの判定、すなわち $a$, $b$ が続く値（以下、それぞれ $a'$, $b'$ とおく）を約数に持つかどうかの判定を行っている。
    - `clews of factors`とコメントがあることから、おそらく $a'$, $b'$ は それぞれ $a$, $b$ が持つ素因数だと推測できる。
    - 実際に[factordb](http://www.factordb.com/index.php)を使うと、 $a'$, $b'$ が共に素数であり、 それぞれ $a$, $b$ が持つ素因数であることが分かる。

以上をまとめると次のようになる。
- 既知の変数： $n$, $e$, $c$, $ab$, ($a'$, $b'$)
- 未知数： $p$, $q$, $x$, $a$, $b$
- 関係式：
    - $n = p \times q$
    - $ab = a \times b$
    - $a = p - x$
    - $b = q - x$
    - $x$, $a$, $b$ は平方数
    - $a$ は $a'$ を素因数に持つ
    - $b$ は $b'$ を素因数に持つ
    - $c = mes^{e} \mod n$（RSA暗号の暗号化）
    - $m = c^d \mod n$（RSA暗号の復号）
    - $d = e^{-1} \mod \varphi (n)$（RSA暗号における $d$ の定義）
    - $\varphi (n) = (p - 1)\times(q - 1)$（RSA暗号における $\varphi (n)$ の定義）

ここで、 $a$と $b$ は平方数なので、それぞれ $a'^2$, $b'^2$ を約数に持つ。

$ab$ を $(a' b')^2$ で割った値を求めて[factordbで素因数分解](http://www.factordb.com/index.php?query=1002777341573073149099549678043369)すると、 $(3 · 173 · 199 · 306606827773)^2$ となる。

つまり、 $a$, $b$ は $3, 173, 199, 306606827773$ の2乗をどちらか一方で約数として持つ。

ここから $a$, $b$ の値の候補が求められる。

![](../assets/factordb.png)

また、 $x$ について
```math
\begin{align}
ab &= (p - x) (q - x) \
&= pq - (p + q) x + x^2 \
&= n - (p + q) x + x^2 　 (\because n = pq)\
&= n - (a + b + 2x) x + x^2 　 (\because a = p - x, b = q - x)\
&= n - (a + b) x - x^2 \
\therefore x^2 + (a + b) x + ab - n &= 0
\end{align}
```

よって、二次方程式の解の公式を用いて $x$ は以下のように求められる。

なお、 $x, a, b$ は正数なので、 $- (a + b)$ は負数となるから $\pm$ については $+$ のみ考えればOK。

```math
x = \frac{- (a + b) + \sqrt{(a + b)^2 - 4 (ab - n)}}{2}
```

$x$ が求まれば $p = a + x$, $q = b + x$ より $p$, $q$ が求まる。

$p$, $q$ が求まると $\varphi (n) = (p - 1)\times(q - 1)$ が求まる。

すると $d = e^{-1} \mod \varphi (n)$ が求まるので、 $m = c^d \mod n$ が求まる。

以上の流れを元にPythonでソースコードを記述し、実行する。

[`solve.py`](./solve.py)
```python:solve.py
from Crypto.Util.number import long_to_bytes, isPrime, inverse
import gmpy2

a2 = 4701715889239073150754995341656203385876367121921416809690629011826585737797672332435916637751589158510308840818034029338373257253382781336806660731169 ** 2
b2 = 35760393478073168120554460439408418517938869000491575971977265241403459560088076621005967604705616322055977691364792995889012788657592539661 ** 2

n = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649220231238608229533197681923695173787489927382994313313565230817693272800660584773413406312986658691062632592736135258179504656996785441096071602835406657489695156275069039550045300776031824520896862891410670249574658456594639092160270819842847709283108226626919671994630347532281842429619719214221191667701686004691774960081264751565207351509289
e = 65537
cipher = 21584943816198288600051522080026276522658576898162227146324366648480650054041094737059759505699399312596248050257694188819508698950101296033374314254837707681285359377639170449710749598138354002003296314889386075711196348215256173220002884223313832546315965310125945267664975574085558002704240448393617169465888856233502113237568170540619213181484011426535164453940899739376027204216298647125039764002258210835149662395757711004452903994153109016244375350290504216315365411682738445256671430020266141583924947184460559644863217919985928540548260221668729091080101310934989718796879197546243280468226856729271148474
ab = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649102926524363237634349331663931595027679709000404758309617551370661140402128171288521363854241635064819660089300995273835099967771608069501973728126045089426572572945113066368225450235783211375678087346640641196055581645502430852650520923184043404571923469007524529184935909107202788041365082158979439820855282328056521446473319065347766237878289
e = 65537

# a2b2 = (a2 * b2) ** 2
# print(ab // a2b2)
# => 1002777341573073149099549678043369
#    = (3 · 173 · 199 · 306606827773)^2

list = [1, 3, 173, 199, 306606827773, 3 * 173, 3 * 199, 3 * 306606827773, 173 * 199, 173 * 306606827773, 199 * 306606827773]
k = 3 * 173 * 199 * 306606827773

for l in list:
    a = a2 * (l ** 2)
    b = b2 * ((k // l) ** 2)
    root, check = gmpy2.iroot(a ** 2 + b ** 2 - 2 * a * b + 4 * n, 2)
    if check:
        x = (- a - b + root) // 2
        p = a + x
        q = b + x
        if isPrime(p):
            if isPrime(q):
                phi = (p-1) * (q-1)
                d = inverse(e, phi)
                m = pow(cipher, d, n)
                mes = long_to_bytes(m)
                print(mes)
```

```
> python .\solve.py
b'ctf4b{c0u1d_y0u_3nj0y_7h3_m4theM4t1c5?}'
```

実行してflagを獲得できた。

```ctf4b{c0u1d_y0u_3nj0y_7h3_m4theM4t1c5?}```
